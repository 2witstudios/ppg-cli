name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  build-dashboard:
    runs-on: macos-26
    outputs:
      ed_signature: ${{ steps.sparkle-sign.outputs.ed_signature }}
      file_length: ${{ steps.sparkle-sign.outputs.file_length }}
    steps:
      - uses: actions/checkout@v4

      - name: Set version from tag
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          BUILD_NUMBER=$(echo "$VERSION" | tr -d '.')
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV

      - name: Import code signing certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
        run: |
          echo "$MACOS_CERTIFICATE" | base64 --decode > certificate.p12
          security create-keychain -p actions build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p actions build.keychain
          security import certificate.p12 -k build.keychain -P "$MACOS_CERTIFICATE_PWD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k actions build.keychain
          rm certificate.p12

      - name: Build dashboard app
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          xcodebuild -scheme "PPG CLI" -configuration Release -derivedDataPath build \
            ARCHS="x86_64 arm64" \
            ONLY_ACTIVE_ARCH=NO \
            CODE_SIGN_IDENTITY="Developer ID Application" \
            DEVELOPMENT_TEAM="$APPLE_TEAM_ID" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_INJECT_BASE_ENTITLEMENTS=NO \
            OTHER_CODE_SIGN_FLAGS="--options runtime --timestamp" \
            MARKETING_VERSION="$VERSION" \
            CURRENT_PROJECT_VERSION="$BUILD_NUMBER" \
            build
        working-directory: PPG CLI

      - name: Re-sign Sparkle embedded binaries
        run: |
          APP_PATH="PPG CLI/build/Build/Products/Release/PPG CLI.app"
          SPARKLE_DIR="$APP_PATH/Contents/Frameworks/Sparkle.framework"

          # Sparkle ships with ad-hoc signed XPC services and helpers.
          # Apple notarization requires every binary to be signed with a
          # Developer ID certificate and hardened runtime. Re-sign inner
          # binaries first (deepest-first), then the framework bundle.
          for item in \
            "$SPARKLE_DIR/Versions/B/XPCServices/Downloader.xpc" \
            "$SPARKLE_DIR/Versions/B/XPCServices/Installer.xpc" \
            "$SPARKLE_DIR/Versions/B/Updater.app" \
            "$SPARKLE_DIR/Versions/B/Autoupdate"; do
            if [ -e "$item" ]; then
              codesign --force --sign "Developer ID Application" \
                --options runtime --timestamp "$item"
            fi
          done

          # Re-sign the framework bundle itself (preserves identifier)
          codesign --force --sign "Developer ID Application" \
            --options runtime --timestamp "$SPARKLE_DIR"

          # Re-sign the main app (outer seal must cover everything)
          codesign --force --sign "Developer ID Application" \
            --options runtime --timestamp "$APP_PATH"

          # Verify the whole bundle
          codesign --verify --deep --strict "$APP_PATH"

      - name: Notarize app
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          APP_PATH="PPG CLI/build/Build/Products/Release/PPG CLI.app"

          # Create zip for notarization submission
          ditto -c -k --keepParent "$APP_PATH" app.zip

          # Submit for notarization and wait, capturing output for the submission ID
          SUBMIT_OUTPUT=$(xcrun notarytool submit app.zip \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait 2>&1) || true
          echo "$SUBMIT_OUTPUT"

          # Extract submission ID and status
          SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep 'id:' | head -1 | awk '{print $2}')
          STATUS=$(echo "$SUBMIT_OUTPUT" | grep 'status:' | tail -1 | awk '{print $2}')

          if [ "$STATUS" != "Accepted" ]; then
            echo "::error::Notarization failed with status: $STATUS"
            # Fetch the log to see why Apple rejected it
            if [ -n "$SUBMISSION_ID" ]; then
              echo "--- Notarization log ---"
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_APP_SPECIFIC_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" || true
            fi
            exit 1
          fi

          # Staple the notarization ticket to the app
          xcrun stapler staple "$APP_PATH"

          rm app.zip

      - name: Create and sign DMG
        run: |
          APP_PATH="PPG CLI/build/Build/Products/Release/PPG CLI.app"
          DMG_PATH="$GITHUB_WORKSPACE/PPG-CLI-Dashboard.dmg"
          hdiutil create -volname "PPG CLI" -srcfolder "$APP_PATH" -ov -format UDZO "$DMG_PATH"
          codesign -s "Developer ID Application" --timestamp "$DMG_PATH"

      - name: Sign DMG with Sparkle EdDSA
        id: sparkle-sign
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          SPARKLE_VERSION="2.9.0"
          curl -L -o sparkle.tar.xz \
            "https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz"
          mkdir sparkle-tools && tar -xf sparkle.tar.xz -C sparkle-tools
          echo "$SPARKLE_PRIVATE_KEY" > sparkle_key
          SIGN_OUTPUT=$(sparkle-tools/bin/sign_update PPG-CLI-Dashboard.dmg --ed-key-file sparkle_key)
          ED_SIGNATURE=$(echo "$SIGN_OUTPUT" | grep -o 'sparkle:edSignature="[^"]*"' | cut -d'"' -f2)
          FILE_LENGTH=$(echo "$SIGN_OUTPUT" | grep -o 'length="[^"]*"' | cut -d'"' -f2)
          echo "ed_signature=$ED_SIGNATURE" >> $GITHUB_OUTPUT
          echo "file_length=$FILE_LENGTH" >> $GITHUB_OUTPUT
          rm sparkle_key sparkle.tar.xz && rm -rf sparkle-tools

      - uses: actions/upload-artifact@v4
        with:
          name: dashboard
          path: PPG-CLI-Dashboard.dmg

  release:
    needs: build-dashboard
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/download-artifact@v4
        with:
          name: dashboard
      - name: Generate release notes
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ github.ref_name }}"

          # Find the previous tag to build changelog from commits
          PREV_TAG=$(git tag --sort=-v:refname | grep '^v' | sed -n '2p')

          # Build changelog from commit messages, filtering out internal-only changes
          CHANGELOG=$(git log "${PREV_TAG}..${VERSION}" --pretty=format:"- %s" \
            --no-merges \
            | grep -v -i "bump version" \
            | grep -v -i "^- Merge" \
            | grep -v -i "notariz" \
            | grep -v -i "fix test" \
            | grep -v -i "fix ci" \
            | grep -v -i "fix appcast" \
            | grep -v -i "fix workflow" \
            | grep -v -i "code sign" \
            || true)

          cat > release-notes.md << 'NOTES_EOF'
          ## Changelog
          NOTES_EOF

          echo "" >> release-notes.md
          echo "$CHANGELOG" >> release-notes.md

          cat >> release-notes.md << 'NOTES_EOF'

          ## Install

          ```bash
          # CLI
          npm install -g pure-point-guard

          # Dashboard app
          ppg install-dashboard
          ```

          Or download **PPG-CLI-Dashboard.dmg** from the assets below.
          NOTES_EOF
          sed -i 's/^          //' release-notes.md

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ github.ref_name }}"
          VERSION_NUM="${VERSION#v}"
          gh release create "$VERSION" \
            --title "PPG CLI ${VERSION_NUM}" \
            --notes-file release-notes.md \
            PPG-CLI-Dashboard.dmg

  update-appcast:
    needs: [build-dashboard, release]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: gh-pages
          fetch-depth: 1

      - name: Update appcast.xml
        env:
          ED_SIGNATURE: ${{ needs.build-dashboard.outputs.ed_signature }}
          FILE_LENGTH: ${{ needs.build-dashboard.outputs.file_length }}
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          BUILD_NUMBER=$(echo "$VERSION" | tr -d '.')
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/${GITHUB_REF_NAME}/PPG-CLI-Dashboard.dmg"
          PUB_DATE=$(date -u '+%a, %d %b %Y %H:%M:%S %z')

          # Insert new item before </channel> using awk (sed can't handle multiline)
          awk -v ver="$VERSION" -v build="$BUILD_NUMBER" -v url="$DOWNLOAD_URL" \
              -v date="$PUB_DATE" -v sig="$ED_SIGNATURE" -v len="$FILE_LENGTH" \
              '/<\/channel>/ {
                print "    <item>"
                print "      <title>Version " ver "</title>"
                print "      <pubDate>" date "</pubDate>"
                print "      <sparkle:version>" build "</sparkle:version>"
                print "      <sparkle:shortVersionString>" ver "</sparkle:shortVersionString>"
                print "      <enclosure url=\"" url "\""
                print "                 type=\"application/octet-stream\""
                print "                 sparkle:edSignature=\"" sig "\""
                print "                 length=\"" len "\" />"
                print "    </item>"
              } {print}' appcast.xml > appcast.tmp && mv appcast.tmp appcast.xml

      - name: Commit and push appcast
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add appcast.xml
          git commit -m "Update appcast for ${GITHUB_REF_NAME}"
          git push
